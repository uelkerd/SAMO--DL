# Consolidated Cloud Run Dockerfile
# Build different variants using build arguments:
# --build-arg BUILD_TYPE=minimal|unified|secure|production
# --build-arg INCLUDE_ML=true|false
# --build-arg INCLUDE_SECURITY=true|false

# Builder stage: create isolated virtual environment with pinned deps
FROM python:3.11-slim-bookworm AS builder

# Declare build arguments in this stage
ARG BUILD_TYPE=minimal
ARG INCLUDE_ML=false
ARG INCLUDE_SECURITY=false

# Environment
ENV PYTHONUNBUFFERED=1 \
    PYTHONDONTWRITEBYTECODE=1

# Install build tools only when ML dependencies are needed
RUN if [ "$INCLUDE_ML" = "true" ]; then \
        apt-get update && apt-get install -y --no-install-recommends \
        gcc=4:12.2.0-* \
        g++=4:12.2.0-* \
        && rm -rf /var/lib/apt/lists/*; \
    fi

# Create venv and install Python deps into it
RUN python -m venv /opt/venv
ENV PATH="/opt/venv/bin:$PATH"

# Use a dedicated build directory for COPY to avoid W1006
WORKDIR /build

# Copy appropriate requirements based on build type
COPY deployment/cloud-run/requirements_${BUILD_TYPE}.txt ./requirements.txt
COPY constraints.txt ./constraints.txt

# Install Python dependencies
RUN python -m pip install --no-cache-dir --upgrade pip==25.2 \
 && pip install --no-cache-dir -c constraints.txt -r requirements.txt

# Create a simple minimal API server for the minimal variant
RUN if [ "$BUILD_TYPE" = "minimal" ]; then \
        echo '#!/usr/bin/env python3' > ./minimal_api_server.py && \
        echo 'from flask import Flask, jsonify' >> ./minimal_api_server.py && \
        echo 'app = Flask(__name__)' >> ./minimal_api_server.py && \
        echo '@app.route("/health")' >> ./minimal_api_server.py && \
        echo 'def health():' >> ./minimal_api_server.py && \
        echo '    return jsonify({"status": "healthy", "variant": "minimal"})' >> ./minimal_api_server.py && \
        echo 'if __name__ == "__main__":' >> ./minimal_api_server.py && \
        echo '    app.run(host="0.0.0.0", port=8080)' >> ./minimal_api_server.py; \
    fi

# =====================================================================
# Runtime stage: minimal image with only runtime deps and non-root user
FROM python:3.11-slim-bookworm

# Declare build arguments again in runtime stage
ARG BUILD_TYPE=minimal
ARG INCLUDE_ML=false
ARG INCLUDE_SECURITY=false

# Environment
ENV PYTHONUNBUFFERED=1 \
    PYTHONDONTWRITEBYTECODE=1 \
    PORT=8080 \
    HF_HOME=/var/tmp/hf-cache \
    XDG_CACHE_HOME=/var/tmp/hf-cache \
    PIP_ROOT_USER_ACTION=ignore

# Install system deps based on build type
RUN if [ "$INCLUDE_ML" = "true" ]; then \
        # ML version needs ffmpeg for audio processing
        apt-get update && apt-get install -y --no-install-recommends \
        ffmpeg=7:5.1.6-0+deb12u1 \
        curl=7.88.1-10+deb12u12 \
        && rm -rf /var/lib/apt/lists/*; \
    else \
        # Minimal version only needs curl for health checks
        apt-get update && apt-get install -y --no-install-recommends \
        curl=7.88.1-10+deb12u12 \
        && rm -rf /var/lib/apt/lists/*; \
    fi

WORKDIR /app

# Bring in Python environment from builder
COPY --from=builder /opt/venv /opt/venv
ENV PATH="/opt/venv/bin:$PATH"

# Pre-bundle ML models for unified build type
RUN if [ "$BUILD_TYPE" = "unified" ] && [ "$INCLUDE_ML" = "true" ]; then \
        # Pre-bundle summarization and ASR models into cache to avoid cold downloads
        python -c "from transformers import AutoTokenizer, T5ForConditionalGeneration; AutoTokenizer.from_pretrained('t5-small'); T5ForConditionalGeneration.from_pretrained('t5-small'); AutoTokenizer.from_pretrained('t5-base'); T5ForConditionalGeneration.from_pretrained('t5-base'); print('Pre-bundled t5-small and t5-base into cache')" \
        && python -c "import whisper; whisper.load_model('small'); print('Pre-bundled whisper-small into cache')"; \
    fi

# App code
COPY src/ ./src/

# Copy additional files from builder stage for specific build types
COPY --from=builder /build/minimal_api_server.py ./minimal_api_server.py

# Create and configure user based on build type
RUN if [ "$INCLUDE_SECURITY" = "true" ]; then \
        # Secure version with enhanced security
        useradd -m -u 1000 appuser \
        && mkdir -p /var/tmp/hf-cache \
        && chown -R appuser:appuser /app /var/tmp/hf-cache \
        && chmod 755 /app /var/tmp/hf-cache; \
    else \
        # Standard version
        useradd -m -u 1000 appuser \
        && mkdir -p /var/tmp/hf-cache \
        && chown -R appuser:appuser /app /var/tmp/hf-cache; \
    fi

USER appuser

EXPOSE 8080

# Healthcheck
HEALTHCHECK --interval=30s --timeout=10s --start-period=20s --retries=3 \
  CMD curl -fsS http://127.0.0.1:${PORT:-8080}/health || exit 1

# Unified API entrypoint (non-root)
# NOTE: Using uvicorn directly for cloud-run deployment (intentional for this environment)
# This is not a security vulnerability - uvicorn is appropriate for cloud-run services
# SECURITY: The "src.unified_ai_api:app" is a Python import path, NOT an API key
# It imports the FastAPI app instance from the unified_ai_api module

# Create entrypoint script based on build type
RUN if [ "$BUILD_TYPE" = "minimal" ]; then \
        echo '#!/bin/sh\nexec python minimal_api_server.py' > /app/entrypoint.sh; \
    elif [ "$BUILD_TYPE" = "secure" ]; then \
        echo '#!/bin/sh\nexec uvicorn src.secure_api_server:app --host 0.0.0.0 --port ${PORT:-8080}' > /app/entrypoint.sh; \
    else \
        echo '#!/bin/sh\nexec uvicorn src.unified_ai_api:app --host 0.0.0.0 --port ${PORT:-8080}' > /app/entrypoint.sh; \
    fi && \
    chmod +x /app/entrypoint.sh

CMD ["/app/entrypoint.sh"]
