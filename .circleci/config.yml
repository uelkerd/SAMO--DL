version: 2.1

# ============================================================================
# SAMO Deep Learning - Simplified CI/CD Pipeline
# Focus: Simple > Complex, keep CI green and fast
# ============================================================================

executors:
  python-simple:
    docker:
      - image: cimg/python:3.12
    resource_class: medium
    working_directory: ~/samo-dl
    environment:
      PYTHONPATH: $CIRCLE_WORKING_DIRECTORY/src

commands:
  smoke_health:
    description: "Run container and poll a health endpoint with retry"
    parameters:
      image:
        type: string
      container_name:
        type: string
      port:
        type: string
        default: "8080"
      host_port:
        type: string
        default: "18080"
      path:
        type: string
        default: "/health"
    steps:
      - run:
          name: Smoke test << parameters.container_name >>
          command: |
            set -euo pipefail
            cleanup() { docker rm -f << parameters.container_name >> >/dev/null 2>&1 || true; }
            trap cleanup EXIT
            # Check if the image exists before running container
            echo "üîç Checking if image << parameters.image >> exists..."
            if ! docker image inspect << parameters.image >> >/dev/null 2>&1; then
              echo "‚ùå Image << parameters.image >> not found! Available images:"
              docker images
              exit 1
            fi
            
            # Start container without host port mapping; probes run inside namespace
            echo "üîç Starting container (no host port mapping; using internal/sidecar probes)..."
            docker run -d --rm --name << parameters.container_name >> << parameters.image >>

            # Debug: Check container started successfully
            echo "üîç Debug: Container started, checking status..."
            docker ps -a | grep << parameters.container_name >> || echo "Container not found in docker ps"

            # Debug: Show available images
            echo "üîç Debug: Available Docker images:"
            docker images | grep samo-dl || echo "No samo-dl images found"

            # Wait for container to be fully ready
            echo "‚è≥ Waiting for container to start..."
            sleep 5

            # Check container logs to see if it's ready
            echo "üîç Checking container logs for readiness..."
            docker logs << parameters.container_name >> || echo "No logs available"

            # Define HEALTH_PATH early so we can use it
            HEALTH_PATH="<< parameters.path >>"
            case "$HEALTH_PATH" in
              /*) ;;
              *) HEALTH_PATH="/$HEALTH_PATH" ;;
            esac

            # Use docker exec to check if the app is responding internally
            echo "üîç Testing internal container connectivity..."
            # Detect available HTTP client in container
            if docker exec << parameters.container_name >> sh -c 'command -v curl' >/dev/null 2>&1; then
              HCMD="curl -fsS --connect-timeout 3 --max-time 5"
              echo "‚úÖ Using curl for health checks"
            elif docker exec << parameters.container_name >> sh -c 'command -v wget' >/dev/null 2>&1; then
              HCMD="wget --quiet --timeout=5 --tries=1 -O -"
              echo "‚úÖ Using wget for health checks"
            else
              echo "‚ÑπÔ∏è Neither curl nor wget found in container; probing via sidecar..."
              # Use a tiny curl container joined to the app container's network namespace
              if docker run --rm --network "container:<< parameters.container_name >>" curlimages/curl:8.9.0 \
                   -fsS --connect-timeout 3 --max-time 5 "http://127.0.0.1:<< parameters.port >>${HEALTH_PATH}" >/dev/null; then
                echo "‚úÖ Sidecar-based health check passed"
                trap - EXIT
                cleanup
                exit 0
              else
                echo "‚ùå Sidecar-based health check failed"
                docker logs << parameters.container_name >> || true
                exit 1
              fi
            fi

            echo "üîç Starting internal container health check on port << parameters.port >>"
            for i in $(seq 1 30); do
              if docker exec << parameters.container_name >> sh -lc "$HCMD \"http://127.0.0.1:<< parameters.port >>${HEALTH_PATH}\"" >/dev/null; then
                echo "‚úÖ Internal health check passed"
                trap - EXIT
                cleanup
                exit 0
              fi
              echo "‚è≥ Health check attempt $i/30 - waiting..."
              sleep 2
            done
            echo "‚ùå Health check failed after 60 seconds (30 attempts √ó 2s)"
            docker logs << parameters.container_name >> || true
            exit 1

jobs:
  # Simple health check to validate basic setup
  basic-setup:
    executor: python-simple
    steps:
      - checkout
      - run:
          name: Environment Check
          command: |
            echo "Python version: $(python3 --version)"
            echo "Pip version: $(python3 -m pip --version)"
            echo "Working directory: $(pwd)"
            echo "PYTHONPATH: $PYTHONPATH"
      - run:
          name: Upgrade pip for faster resolver
          command: |
            python3 -m pip install --upgrade pip
      - run:
          name: Install Core Dev Dependencies (optimized)
          command: |
            # Install with optimized flags to prevent timeout
            python3 -m pip install \
              --no-compile \
              --disable-pip-version-check \
              --timeout 300 \
              -c dependencies/constraints.txt \
              -r dependencies/requirements-api.txt \
              -r dependencies/requirements-dev.txt
            # Sanity check to fail fast if imports break
            PYTHONPATH="$CIRCLE_WORKING_DIRECTORY/src" python3 -c "import sys; import fastapi, uvicorn, pydantic, requests; print('‚úÖ core imports OK')" || echo "‚ùå Import failed"
      - run:
          name: Test Basic API Import
          command: |
            export PATH="$HOME/.local/bin:$PATH"
            PYTHONPATH="$CIRCLE_WORKING_DIRECTORY/src" python3 -c "from src.unified_ai_api import app; print('‚úÖ API imports successfully!')"
      - run:
          name: Test API Health Check
          command: |
            export PATH="$HOME/.local/bin:$PATH"
            PYTHONPATH="$CIRCLE_WORKING_DIRECTORY/src" python3 -c "import importlib.util as u, sys; sys.exit(0 if u.find_spec('fastapi') is None else 1)" \
              && echo '‚ö†Ô∏è FastAPI not installed; skipping health check.' \
              || PYTHONPATH="$CIRCLE_WORKING_DIRECTORY/src" python3 -c "from fastapi.testclient import TestClient; from src.unified_ai_api import app; c=TestClient(app); r=c.get('/health'); assert r.status_code==200, f'Health check failed: {r.status_code}'; print('‚úÖ API health check passed!')"

  safety-scan:
    executor: python-simple
    steps:
      - checkout
      - run:
          name: Create virtual environment and install dependencies with constraints
          command: |
            set -euo pipefail
            python3 -m venv /tmp/safety-scan-env
            source /tmp/safety-scan-env/bin/activate
            pip install --upgrade pip
            
            # Install project dependencies with constraints for accurate scanning
            echo "üì¶ Installing project dependencies with constraints for vulnerability scanning..."
            
            # Install dependencies with constraints to ensure Safety scans against locked versions
            INSTALL_ARGS=""
            for REQ_FILE in dependencies/requirements-api.txt dependencies/requirements-dev.txt dependencies/requirements-ml.txt; do
              if [ -f "$REQ_FILE" ]; then
                INSTALL_ARGS="$INSTALL_ARGS -r $REQ_FILE"
                echo "‚úÖ Will install: $REQ_FILE"
              else
                echo "‚ö†Ô∏è Requirements file not found: $REQ_FILE (skipping)"
              fi
            done
            
            # Install with constraints to get exact versions that Safety should scan
            if [ -n "$INSTALL_ARGS" ]; then
              pip install -c dependencies/constraints.txt $INSTALL_ARGS
              echo "‚úÖ Dependencies installed with constraints applied"
            else
              echo "‚ùå No requirements files found to install."
              exit 1
            fi
      - run:
          name: Install and run Safety scan
          command: |
            set -euo pipefail
            source /tmp/safety-scan-env/bin/activate
            
            # Install Safety v3.6.x (pinned version)
            pip install safety==3.6.0
            
            # Install jq for JSON parsing (if not already available)
            if ! command -v jq &> /dev/null; then
              sudo apt-get -o Acquire::Retries=3 update && sudo apt-get install -y jq
            fi
            
            echo "üîç Running Safety scan..."
            echo "üîç Safety version: $(safety --version)"

            # Run safety scan and capture exit code
            # Build safety command with file existence checks
            set +e  # Temporarily disable exit on error to capture exit code
            
            # Note: Removed .safety-policy.yml due to Safety 3.6.0 compatibility issues
            # The file was v3.0 but 'safety check' only supports ‚â§v2.0, and Safety was
            # auto-discovering it even without --policy-file flag. Since it only enabled
            # default behavior, we use Safety's built-in defaults instead.
            echo "‚ÑπÔ∏è Using Safety default policy (dependency vulnerability scanning enabled)"
            
            # Scan installed packages (which were installed with constraints applied)
            # This ensures Safety checks against the exact constrained versions
            echo "üîç Scanning installed packages (constrained versions)..."
            
            # Execute safety check on installed packages
            safety check --output json > safety-report.json
            EXIT_CODE=$?
            set -e  # Re-enable strict error handling

            # Show the JSON report for transparency
            echo "üìã Safety scan report:"
            cat safety-report.json | jq '.' || cat safety-report.json

            # Handle exit codes explicitly
            if [ "$EXIT_CODE" -eq 0 ]; then
              echo "‚úÖ No vulnerabilities found!"
            elif [ "$EXIT_CODE" -eq 64 ]; then
              echo "‚ö†Ô∏è Safety scan found vulnerabilities (exit code: $EXIT_CODE)"

              # Use jq to properly parse JSON and check for high/critical severities
              HIGH_CRITICAL_COUNT=0
              if [ -f safety-report.json ] && [ -s safety-report.json ]; then
                # Count high and critical vulnerabilities using jq
                HIGH_CRITICAL_COUNT=$(jq '[.vulnerabilities[]?
                  | ((.severity // .cvss_v3_severity // "") | ascii_downcase) as $sev
                  | select($sev == "high" or $sev == "critical")
                ] | length' safety-report.json 2>/dev/null || echo "0")
              fi

              if [ "$HIGH_CRITICAL_COUNT" -gt 0 ]; then
                echo "‚ùå Found $HIGH_CRITICAL_COUNT High/Critical vulnerabilities - failing CI"
                exit 1
              else
                echo "‚ö†Ô∏è Only Low/Medium vulnerabilities found - allowing build to continue"
              fi
            else
              echo "‚ùå Safety scan failed unexpectedly (exit code: $EXIT_CODE)"
              exit "$EXIT_CODE"
            fi

            echo "‚úÖ Safety scan completed"

            # Cleanup
            deactivate || true
            rm -rf /tmp/safety-scan-env
      - store_artifacts:
          path: safety-report.json
          destination: safety/

  # Basic linting (optional - won't fail build)
  code-quality:
    executor: python-simple
    steps:
      - checkout
      - run:
          name: Install Linting Tools
          command: |
            python3 -m pip install --upgrade pip
            python3 -m pip install --user ruff==0.6.9
      - run:
          name: Run Linting (Non-blocking)
          command: |
            export PATH="$HOME/.local/bin:$PATH"
            ruff check src/ || echo "‚ö†Ô∏è Linting issues found (non-blocking)"
            ruff format --check src/ || echo "‚ö†Ô∏è Formatting issues found (non-blocking)"

  # Simple unit tests (placeholder)
  unit-tests:
    executor: python-simple
    steps:
      - checkout
      - run:
          name: Install Test Dependencies (optimized)
          command: |
            python3 -m pip install --upgrade pip
            # Install with optimized flags to prevent timeout
            python3 -m pip install \
              --no-compile \
              --disable-pip-version-check \
              --timeout 300 \
              -c dependencies/constraints.txt \
              -r dependencies/requirements-api.txt \
              -r dependencies/requirements-dev.txt \
              -r dependencies/requirements-ml.txt
            python3 -c "import sys; import pytest, ruff, torch, transformers, pandas; print('‚úÖ test deps imports OK')" || echo "‚ùå Import failed"
      - run:
          name: Run Basic Tests
          command: |
            export PATH="$HOME/.local/bin:$PATH"
            PYTHONPATH="$CIRCLE_WORKING_DIRECTORY/src" python3 -m pytest --version
            echo "‚úÖ Test framework ready"

  docker-build:
    docker:
      - image: cimg/base:stable
    resource_class: medium
    working_directory: ~/samo-dl
    steps:
      - checkout
      - setup_remote_docker:
          docker_layer_caching: true
      - run:
          name: Verify Docker and print version
          command: |
            docker --version
      - run:
          name: Build app image (minimal)
          command: |
            DOCKER_BUILDKIT=1 docker build \
              --build-arg BUILD_TYPE=minimal \
              --pull \
              --progress=plain \
              --platform linux/amd64 \
              --build-arg PIP_CONSTRAINT=dependencies/constraints.txt \
              -f deployment/docker/Dockerfile.app \
              -t samo-dl-app:${CIRCLE_SHA1:0:7} \
              -t samo-dl-app:latest \
              .
      - smoke_health:
          image: samo-dl-app:${CIRCLE_SHA1:0:7}
          container_name: app-minimal-test
      - run:
          name: Build app image (unified ML)
          command: |
            DOCKER_BUILDKIT=1 docker build \
              --build-arg BUILD_TYPE=unified \
              --build-arg INCLUDE_ML=true \
              --pull \
              --progress=plain \
              --platform linux/amd64 \
              --build-arg PIP_CONSTRAINT=dependencies/constraints.txt \
              -f deployment/docker/Dockerfile.app \
              -t samo-dl-app-unified:${CIRCLE_SHA1:0:7} \
              -t samo-dl-app-unified:latest \
              .
      - smoke_health:
          image: samo-dl-app-unified:${CIRCLE_SHA1:0:7}
          container_name: app-unified-test
      - run:
          name: Build training image
          command: |
            DOCKER_BUILDKIT=1 docker build \
              --pull \
              --progress=plain \
              -f deployment/docker/Dockerfile.train \
              -t samo-dl-train:${CIRCLE_SHA1:0:7} \
              -t samo-dl-train:latest \
              .
      - run:
          name: Smoke test training image (imports)
          command: |
            docker run --rm --entrypoint python samo-dl-train:${CIRCLE_SHA1:0:7} -c "import torch, transformers; print('‚úÖ train image imports OK')"

workflows:
  simple-ci:
    jobs:
      - basic-setup
      - safety-scan:
          requires:
            - basic-setup
      - code-quality:
          requires:
            - basic-setup
      - unit-tests:
          requires:
            - basic-setup
      - docker-build:
          requires:
            - basic-setup

  quick-check:
    jobs:
      - basic-setup:
          filters:
            branches:
              only:
                - /^bootstrap-only\/.*/
